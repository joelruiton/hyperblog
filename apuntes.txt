git init: lo usamos para determinar la carpeta en la que vamos a trabajar.

git status: lo usamos para saber si tenemos un archivo añadido o borrado en nuestro proyecto, para saber en la rama en la 
que estamos y si tenemos commits.

git add: es para añadir un archivo a nuestra rama seguidamente ponemos entre comillas el nombre de nuestro archivo o 
poner un punto para añadir todos los archivos de nuestra carpeta.

git rm: lo usamos para borrar un archivo que hayamos añadido
git rm --cached: Elimina los archivos de nuestro repositorio local y del área de staging, pero los mantiene en nuestro 
disco duro. Básicamente le dice a Git que deje de trackear el historial de cambios de estos archivos, por lo que pasaran 
a un estado untracked.
git rm --force: Elimina los archivos de Git y del disco duro. Git siempre guarda todo, por lo que podemos acceder al 
registro de la existencia de los archivos, de modo que podremos recuperarlos si es necesario (pero debemos usar comandos 
más avanzados).

git commit: se usa para añadir un commit a nuestra rama, también podemos ponerle un -m seguidamente ponemos entre comillas 
nuestro ensaje.

git config: muestra configuraciones de git también podemos usar –list para mostrar la configuración por defecto de nuestro 
git y si añadimos --show-origin inhales nos muestra las configuraciones guardadas y su ubicación.

git config --global user.name: cambia de manera global el nombre del usuario, seguidamente ponemos entre comillas nuestro 
nombre.

git config --global user.email: cambia de manera global el email del usuario, seguidamente ponemos entre comillas nuestro 
nombre.

git log "archivo": se usa para ver la historia de nuestros archivos, los commits, el usuario que lo cambió, cuando se 
realizaron los cambios etc. seguidamente ponemos el nombre de nuestro archivo.

git show "archivo": para ver los cambios historicos del archivo indicado

git diff "commit2" "commit1": compara 2 commits por su ID
git diff: muestra diferencias entre el directorio actual y staging

git reset --soft: Borramos todo el historial y los registros de Git pero guardamos los cambios que tengamos en Staging, 
así podemos aplicar las últimas actualizaciones a un nuevo commit.
git reset --hard: Borra todo. Todo todito, absolutamente todo. Toda la información de los commits y del área de staging 
se borra del historial.
git reset HEAD: Este es el comando para sacar archivos del área de staging. No para borrarlos ni nada de eso, solo para 
que los últimos cambios de estos archivos no se envíen al último commit, a menos que cambiemos de opinión y los 
incluyamos de nuevo en staging con git add, por supuesto.

git log --stat: Muestra la historia, incluyendo la diferencia de bytes

git checkout "commit" "archivo": trae de regreso la version (como modificación, podría deshacerse) indicada del archivo 
indicado.

git commit -am "mensaje": hace un git add (sin considerar archivos nuevos), y seguidamente un git commit con el mensaje
indicado

git checkout master "archivo": trae de regreso la version actual de master indicada del archivo 
indicado.

INCLUIMOS EL CONCEPTO DE REPOSITORIO REMOTO (GITHUB, GITLAB, BITBUCKET)
git clone "url": se trae el contenido del master a nuestro repositorio local.
git push: despues de haber enviado cambios del directorio de trabajo a staging con git add, y despues de haber pasado
a staging con git commit, se usa git push para pasar del repositorio local al repositorio remoto

git fetch: trae la ultima version de master del repositorio remoto al repositorio local (sin cambiar el directorio 
de trabajo)
git merge: trae toda la info del repositorio local y la fusiona con el directorio de trabajo
git pull: hace git fetch y git merge

BRANCHS
git branch "branch": crea un nuevo branch con el nombre especificado
git checkout "branch": te mueve al branch indicado
git checkout -b "nombre_rama": Este comando es una fusión entre “git branch” y “git checkout”, y su funcionamiento es el siguiente:
- Crea una rama llamada “nombre_rama”
- Hace un checkout de la rama “nombre_rama”

MERGE
es un commit, por lo tanto tambien requiere un mensaje
es una buena practica invocarlo desde master para que el head se quede en master
git merge "branch"

LLAVES PUBLICAS Y PRIMARIAS
Generar una nueva llave SSH: (Cualquier sistema operativo)
ssh-keygen -t rsa -b 4096 -C "youremail@example.com"

Comprobar proceso y agregarlo (Windows)
eval $(ssh-agent - s)
ssh-add ~/.ssh/id_rsa

Comprobar proceso y agregarlo (Mac)
eval "$(ssh-agent -s)"

¿Usas macOS Sierra 10.12.2 o superior?
Haz lo siguiente:
cd ~/.ssh
Crea un archivo config…
Con Vim vim config
Con VSCode code config
Pega la siguiente configuración en el archivo…
Host *
  AddKeysToAgent yes
  UseKeychain yes
  IdentityFile ~/.ssh/id_rsa
Agrega tu llave
ssh-add -K ~/.ssh/id_rsa

REPOSITORIO REMOTO (GITHUB)
git remote add origin "url": con esto le añadimos un repositorio remoto a nuestro proyecto local actual
git remote -v: verifica la existencia del repositorio remoto
git push origin master: fusiona una copia del master local con el remoto (github actualmente cambio master por main)
PARA CAMBIAR DE MASTER A MAIN
git branch -m main: crea la rama main localmente y la setea como el nuevo master
git push origin main: fusiona una copia del main local con el remoto
git pull origin main: fusiona una copia del main remoto con el local (en caso ya tengamos un proyecto en curso puede dar
un warning indicando que las historias del origen remoto y local no guardan correlacion)
git pull origin main --allow-unrelated-histories: fusiona una copia del main remoto con el local ignorando si las historias
guardan relación o no
UNA VEZ ENLAZADOS AL REPOSITORIO REMOTO ES BUENA PRACTICA HACER GIT PULL ORIGIN MAIN ANTES DE HACER LOS COMMITS DE MODO QUE NOS
ASEGURAMOS DE SIEMPRE ESCRIBIR SOBRE LA ULTIMA VERSION